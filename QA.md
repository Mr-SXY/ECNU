#### **范型 类型擦除**

​	自动装箱用的是ValueOf方法`Integer i = 3`；当执行算术运算时，会自动拆箱。

#### **重写equals()必须重写hashcode()？**

​	对于基本类型	==	比较的是数值；对于引用数据类型	==	比较的是地址
​	equals()	源码就是	==	；不能用于比较基本数据类型。
​	*若两个对象相等，则hashcode一定相等；但两个对象的hashcode相等，他们不一定equals()。*

> Sting中的equals方法是**重写**过的，Object的equals方法比较的是`对象的内存地址`，而String比较的是`对象的值`；创建String类对象时，虚拟机会在常量池中查找有没有 已经存在的与要创建的值相同的对象，如果有就把他赋给当前引用。

构造方法的作用：用于类对象的初始化

多态

从键盘输入两种方法：BufferedReader	/	Scanner

字节/字符流	BIO/NIO/AIO

POJO类属性使用包装类数据类型；RPC方法的返回值使用包装数据类型；局部变量使用基本数据类型

浮点数之间的等值判断采用BigDecimal	（精度丢失）

Arrays.asList()方法：1、返回的是Arrays的内部类而不是ArrayList；2、是一个泛型方法，传入的数组需为对象数组，若传入int[]（基本类型数组），则整个数组作为List的唯一元素。

equals()的空指针异常

不在foreach里进行list的add(),remove()操作，可用iterator或者list.removeIf()方法

网关



#### **final关键字的特点：**

- ​	final修饰的类不能被继承，final类中的所有成员方法都会被隐式的指定为final方法；
- ​	final修饰的方法不能被重写；
- ​	final修饰的变量是常量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能让其指向另一个对象。

#### **计算机网络7层模型**

​	物理层，数据链路层，网络层，传输层，会话层，表示层，应用层

#### **应用层协议有哪些？**



#### **浏览器输入URL之后的过程？**



#### **HTTP状态码**

​	200 - 请求成功
​	301 - 资源（网页）被永久转移到其他URL
​	302 - 资源（网页）被临时移动到其他URL
​	404 - 请求的资源不存在
​	500 - 内部服务器错误；

#### **HTTP状态码分类**：

​	1**	：信息，服务器收到请求，需要请求者继续执行操作
​	2**	： 成功，操作被成功接收并处理
​	3**	：重定向，需要进一步的操作以完成请求
​	4**	：客户端错误，请求包含语法错误或无法完成请求
​	5**	：服务器错误，服务器在处理请求的过程中发生了错误

#### **四次挥手过程？**

#### **三次握手有哪些攻击方式？**

#### **证书在SSL过程中的作用？**

#### **HTTPS通信过程以及SSL为什么采用混合加密方式？**

#### **操作系统的PageFault？**

#### **Mysql的B+树索引和红黑树、普通二叉树的区别？**

#### **CAS解决ABA问题，如何保证原子性？**

​	计数器法；版本号法

#### **描述volatile**

#### **原子类的实现方式**

#### **锁的AQS的实现方式**

#### **列举知道的锁**

#### **JAVA类加载机制双亲委派？**

​	如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就**成功返回**，倘若父类加载器无法完成此加载任务，**子加载器才会尝试自己去加载**。

#### **JAVA的垃圾回收机制？**



#### **HashMap扩容机制，线程安全？ConCurrentHashMap？**

#### **引用**

​	由强到弱分为`强引用`；`软引用`：SoftReference类实现；`弱引用`：WeakReference类实现；`虚引用`：PhantomReference类实现，共4种。

#### **死锁的四个条件**

- ​	互斥条件：该资源任意一个时刻只有一个线程占用；
- ​	请求与保持条件：一个进程由于请求资源而阻塞，对已经获得的资源保持不放；
- ​	不剥夺条件：线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源；
- ​	循环等待条件：若干进程之间形成一种首尾相连的的循环等待资源的关系。


#### **乐观锁与悲观锁**

​	乐观锁多用于**多读**的场景，悲观锁多用于**多写**的场景。

​	乐观锁主要的两种实现方式：版本号机制、CAS

##### 	乐观锁的缺点

- ​	ABA问题：JDK 1.5 以后的 `AtomicStampedReference 类`就提供了此种能力，其中的 `compareAndSet 方法`就是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。
- ​	循环时间长，开销大：自旋CAS长时间不成功会带来执行开销。
- ​	只能保证一个共享变量的原子操作：`AtomicReference类`来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行 CAS 操作.所以我们可以使用锁或者利用`AtomicReference类`把多个共享变量合并成一个共享变量来操作。

#### **this, super不能用在static方法中？**

​	被 static 修饰的成员属于类，不属于单个这个类的某个对象，被类中所有对象共享。而 this 代表对本类对象的引用，指向本类对象；而 super 代表对父类对象的引用，指向父类对象；所以， **this和super是属于对象范畴的东西，而静态方法是属于类范畴的东西**。

#### **static{}静态代码块与{}非静态代码块**

​	执行顺序：静态代码块 > 非静态代码块 > 构造方法 > 静态方法中的内容 > 静态方法中代码块。

### 线程池

#### 线程池的七大参数？

​	线程池的构造函数有7个参数，分别是corePoolSize、maximumPoolSize、keepAliveTime、unit、workQueue、threadFactory、handler.
- corePoolSize：核心线程数
- maximumPoolSize：最大线程数，线程池允许创建的最大线程数。
- workQueue：
  任务队列，BlockingQueue 接口的某个实现（常使用 ArrayBlockingQueue 和 LinkedBlockingQueue）。
- keepAliveTime：
  空闲线程的保活时间，如果某线程的空闲时间超过这个值都没有任务给它做，那么可以被关闭了。注意这个值并不会对所有线程起作用，如果线程池中的线程数少于等于核心线程数 corePoolSize，那么这些线程不会因为空闲太长时间而被关闭，当然，也可以通过调用 `allowCoreThreadTimeOut(true)`使核心线程数内的线程也可以被回收。
- unit：空闲线程存活时间单位
- threadFactory：用于生成线程
- handler：拒绝策略	

#### java 线程池有哪些关键属性？

> corePoolSize，maximumPoolSize，workQueue，keepAliveTime，rejectedExecutionHandler
> corePoolSize 到 maximumPoolSize 之间的线程会被回收，当然 corePoolSize 的线程也可以通过设置而得到回收（allowCoreThreadTimeOut(true)）。
> workQueue 用于存放任务，添加任务的时候，如果当前线程数超过了 corePoolSize，那么往该队列中插入任务，线程池中的线程会负责到队列中拉取任务。
> keepAliveTime 用于设置空闲时间，如果线程数超出了 corePoolSize，并且有些线程的空闲时间超过了这个值，会执行关闭这些线程的操作
> rejectedExecutionHandler 用于处理当线程池不能执行此任务时的情况，默认有**抛出 RejectedExecutionException 异常**、**忽略任务**、**使用提交任务的线程来执行此任务**和**将队列中等待最久的任务删除，然后提交此任务**这四种策略，默认为抛出异常。

#### 说说线程池中的线程创建时机？

> 1. 如果当前线程数少于 corePoolSize，那么提交任务的时候创建一个新的线程，并由这个线程执行这个任务；
> 2. 如果当前线程数已经达到 corePoolSize，那么将提交的任务添加到阻塞队列中，等待线程池中的线程去阻塞队列中取任务；
> 3. 如果阻塞队列已满，那么创建新的线程来执行任务，需要保证池中的线程数不会超过 maximumPoolSize，如果此时线程数超过了 maximumPoolSize，那么执行拒绝策略。

#### 什么时候会执行拒绝策略？

> 1. workers 的数量达到了 corePoolSize（任务此时需要进入任务队列），任务入队成功，与此同时线程池被关闭了，而且关闭线程池并没有将这个任务出队，那么执行拒绝策略。这里说的是非常边界的问题，入队和关闭线程池并发执行，读者仔细看看 execute 方法是怎么进到第一个 reject(command) 里面的。
> 2. workers 的数量大于等于 corePoolSize，将任务加入到任务队列，可是队列满了，任务入队失败，那么准备开启新的线程，可是线程数已经达到 maximumPoolSize，那么执行拒绝策略。

### Atomic原子类

#### 基本类型原子类

​	`AtomicInteger`类

#### 数组类型原子类

​	`AtomicIntegerArray`类

#### 引用类型原子类

​	基本原子类只更新一个变量，引用原子类可**更新多个变量**：

- `AtomicReference`类
- `AtomicStampedReference`类：带有版本号，解决CAS的ABA问题
- `AtomicMarkableReference`类：带有标记

#### 对象属性修改类型原子类



### Spring

#### IoC和AOP

​	IoC控制反转：传统程序通过程序员自身在类内`new`依赖对象，现在通过IoC容器注入依赖对象。依赖注入(DI)是实现控制反转的方式。
​	AOP：面向切面编程，即在不改变原有程序的基础上，横向扩展功能。

#### Spring中涉及的设计模式

#### 常见注解



## 数据库

### mysql

#### 事务的特性？

​	**原子性：** 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；
​	**一致性：** 执行事务前后，数据保持一致，例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的；
​	**隔离性：** 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；
​	**持久性：** 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。

#### 并发事务带来的问题？

​	**脏读**：一个事务访问并修改了数据，但没有提交到数据库。此时另一个事务也访问并使用了这个数据，那这个事务读取的数据是“脏数据”。
​	**幻读**：一个事务读取了几行数据，此时另一个并发事务写入了一些数据，第一个事务就会发现多了几条原本不存在的数据。
​	**丢失修改**：两个事务同时读取一个数据并修改，会导致先修改的事务的修改操作丢失。
​	**不可重复读**：一个事务在多次读取同一数据时，被另一个事务修改数据导致读取的数据内容前后不一致。

#### 事务的隔离级别？

​	**读取未提交**：允许读取尚未提交的数据，导致脏读、不可重复读、幻读；
​	**读取已提交**：允许读取并发事务已经提交的数据，阻止脏读，导致不可重复读、幻读；
​	**可重复读**：对同一字段的多次读取结果都是一致的，阻止脏读、不可重复读，导致幻读；
​	**可序列化(Serializable)**：所有事务依次逐个执行，最高隔离级别。

#### 为什么InnoDB使用B+树？

​	从结构比较来看，B树相比B+树的一个主要区别就在于B树的分支节点上存储着数据，而B+树的分支节点只是叶子节点的索引而已。

- 磁盘IO读写次数相比B树降低了
  在B+树中，其非叶子的内部节点都变成了key值，因此其内部节点相对B 树更小。如果把所有同一内部节点的key存放在同一盘块中，那么盘块所能容纳的key数量也越多。一次性读内存中的需要查找的key值也就越多。相对来说IO读写次数也就降低了。
- 每次查询的时间复杂度是固定的
  在B+树中，由于分支节点只是叶子节点的索引，所以对于任意关键字的查找都必须从根节点走到分支节点，所有关键字查询路径长度相同，每次查询的时间复杂度是固定的。但是在B树中，其分支节点上也保存有数据，对于每一个数据的查询所走的路径长度是不一样的，所以查询效率也不一样。
- 遍历效率更高
  由于B+树的数据都存储在叶子节点上，分支节点均为索引，方便扫库，只需扫一遍叶子即可。但是B树在分支节点上都保存着数据，要找到具体的顺序数据，需要执行一次中序遍历来查找。所以B+树更加适合范围查询的情况，在解决磁盘IO性能的同时解决了B树元素遍历效率低下的问题。
- **因为B树不管叶子节点还是非叶子节点，都会保存数据，这样导致在非叶子节点中能保存的指针数量变少（有些资料也称为扇出），指针少的情况下要保存大量数据，只能增加树的高度，导致IO操作变多，查询性能变低**

#### 锁机制--表锁与行锁

MyISAM和InnoDB存储引擎使用的锁：

- MyISAM采用表级锁(table-level locking)。
- InnoDB支持行级锁(row-level locking)和表级锁,默认为行级锁

表级锁和行级锁对比：

- **表级锁：** MySQL中锁定 **粒度最大** 的一种锁，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁。其锁定粒度最大，触发锁冲突的概率最高，并发度最低，MyISAM和 InnoDB引擎都支持表级锁。
- **行级锁：** MySQL中锁定 **粒度最小** 的一种锁，只针对当前操作的行进行加锁。 行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。

#### mysql数据库日志？

#### 分库分表

### Redis

#### 	缓存穿透和缓存雪崩

> 缓存穿透：大量请求的 key 根本不存在于缓存中，导致请求直接到了数据库上，根本没有经过缓存这一层。
> 解决方案：布隆过滤器

> 缓存雪崩：缓存在同一时间大面积的失效，后面的请求都直接落到了数据库上，造成数据库短时间内承受大量请求；或者有一些被大量访问数据（热点缓存）在某一时刻大面积失效，导致对应的请求直接落到了数据库上。
> 解决方案：合理设置过期时间时间；限流。

#### redis常见数据结构

​	String，List，Hash，Set，Sorted set

#### redis内存淘汰机制？

#### redis持久化机制？

#### redis缓存读写策略？

​	Cache Aside Pattern（旁路缓存模式）
​	Read/Write Through Pattern（读写穿透）
​	Write Behind Pattern（异步缓存写入）