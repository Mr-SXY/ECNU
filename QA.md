#### **范型 类型擦除**

​	自动装箱用的是ValueOf方法`Integer i = 3`；当执行算术运算时，会自动拆箱。

#### **重写equals()必须重写hashcode()？**

​	对于基本类型	==	比较的是数值；对于引用数据类型	==	比较的是地址
​	equals()	源码就是	==	；不能用于比较基本数据类型。
​	*若两个对象相等，则hashcode一定相等；但两个对象的hashcode相等，他们不一定equals()。*

> Sting中的equals方法是**重写**过的，Object的equals方法比较的是`对象的内存地址`，而String比较的是`对象的值`；创建String类对象时，虚拟机会在常量池中查找有没有 已经存在的与要创建的值相同的对象，如果有就把他赋给当前引用。

构造方法的作用：用于类对象的初始化

多态

从键盘输入两种方法：BufferedReader	/	Scanner

字节/字符流	BIO/NIO/AIO

POJO类属性使用包装类数据类型；RPC方法的返回值使用包装数据类型；局部变量使用基本数据类型

浮点数之间的等值判断采用BigDecimal	（精度丢失）

Arrays.asList()方法：1、返回的是Arrays的内部类而不是ArrayList；2、是一个泛型方法，传入的数组需为对象数组，若传入int[]（基本类型数组），则整个数组作为List的唯一元素。

equals()的空指针异常

不在foreach里进行list的add(),remove()操作，可用iterator或者list.removeIf()方法

网关



#### **final关键字的特点：**

- ​	final修饰的类不能被继承，final类中的所有成员方法都会被隐式的指定为final方法；
- ​	final修饰的方法不能被重写；
- ​	final修饰的变量是常量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能让其指向另一个对象。

#### **计算机网络7层模型**

​	物理层，数据链路层，网络层，传输层，会话层，表示层，应用层

#### **应用层协议有哪些？**



#### **浏览器输入URL之后的过程？**



#### **HTTP状态码**

​	200 - 请求成功
​	301 - 资源（网页）被永久转移到其他URL
​	302 - 资源（网页）被临时移动到其他URL
​	404 - 请求的资源不存在
​	500 - 内部服务器错误；

#### **HTTP状态码分类**：

​	1**	：信息，服务器收到请求，需要请求者继续执行操作
​	2**	： 成功，操作被成功接收并处理
​	3**	：重定向，需要进一步的操作以完成请求
​	4**	：客户端错误，请求包含语法错误或无法完成请求
​	5**	：服务器错误，服务器在处理请求的过程中发生了错误

#### **四次挥手过程？**

#### **三次握手有哪些攻击方式？**

#### **证书在SSL过程中的作用？**

#### **HTTPS通信过程以及SSL为什么采用混合加密方式？**

#### **操作系统的PageFault？**

#### **Mysql的B+树索引和红黑树、普通二叉树的区别？**

#### **CAS解决ABA问题，如何保证原子性？**

​	计数器法；版本号法

#### **描述volatile**

#### **原子类的实现方式**

#### **锁的AQS的实现方式**

#### **列举知道的锁**

#### **JAVA的垃圾回收机制？**



#### **HashMap扩容机制，线程安全？ConCurrentHashMap？**

#### **引用**

​	由强到弱分为`强引用`；`软引用`：SoftReference类实现；`弱引用`：WeakReference类实现；`虚引用`：PhantomReference类实现，共4种。

#### **死锁的四个条件**

- ​	互斥条件：该资源任意一个时刻只有一个线程占用；
- ​	请求与保持条件：一个进程由于请求资源而阻塞，对已经获得的资源保持不放；
- ​	不剥夺条件：线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源；
- ​	循环等待条件：若干进程之间形成一种首尾相连的的循环等待资源的关系。


#### **乐观锁与悲观锁**

​	乐观锁多用于**多读**的场景，悲观锁多用于**多写**的场景。

​	乐观锁主要的两种实现方式：版本号机制、CAS

##### 	乐观锁的缺点

- ​	ABA问题：JDK 1.5 以后的 `AtomicStampedReference 类`就提供了此种能力，其中的 `compareAndSet 方法`就是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。
- ​	循环时间长，开销大：自旋CAS长时间不成功会带来执行开销。
- ​	只能保证一个共享变量的原子操作：`AtomicReference类`来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行 CAS 操作.所以我们可以使用锁或者利用`AtomicReference类`把多个共享变量合并成一个共享变量来操作。

#### **this, super不能用在static方法中？**

​	被 static 修饰的成员属于类，不属于单个这个类的某个对象，被类中所有对象共享。而 this 代表对本类对象的引用，指向本类对象；而 super 代表对父类对象的引用，指向父类对象；所以， **this和super是属于对象范畴的东西，而静态方法是属于类范畴的东西**。

#### **static{}静态代码块与{}非静态代码块**

​	执行顺序：静态代码块 > 非静态代码块 > 构造方法 > 静态方法中的内容 > 静态方法中代码块。

### 线程池

#### 线程池的七大参数？

​	线程池的构造函数有7个参数，分别是corePoolSize、maximumPoolSize、keepAliveTime、unit、workQueue、threadFactory、handler.
- corePoolSize：核心线程数
- maximumPoolSize：最大线程数，线程池允许创建的最大线程数。
- workQueue：
  任务队列，BlockingQueue 接口的某个实现（常使用 ArrayBlockingQueue 和 LinkedBlockingQueue）。
- keepAliveTime：
  空闲线程的保活时间，如果某线程的空闲时间超过这个值都没有任务给它做，那么可以被关闭了。注意这个值并不会对所有线程起作用，如果线程池中的线程数少于等于核心线程数 corePoolSize，那么这些线程不会因为空闲太长时间而被关闭，当然，也可以通过调用 `allowCoreThreadTimeOut(true)`使核心线程数内的线程也可以被回收。
- unit：空闲线程存活时间单位
- threadFactory：用于生成线程
- handler：拒绝策略	

#### java 线程池有哪些关键属性？

> corePoolSize，maximumPoolSize，workQueue，keepAliveTime，rejectedExecutionHandler
> corePoolSize 到 maximumPoolSize 之间的线程会被回收，当然 corePoolSize 的线程也可以通过设置而得到回收（allowCoreThreadTimeOut(true)）。
> workQueue 用于存放任务，添加任务的时候，如果当前线程数超过了 corePoolSize，那么往该队列中插入任务，线程池中的线程会负责到队列中拉取任务。
> keepAliveTime 用于设置空闲时间，如果线程数超出了 corePoolSize，并且有些线程的空闲时间超过了这个值，会执行关闭这些线程的操作
> rejectedExecutionHandler 用于处理当线程池不能执行此任务时的情况，默认有**抛出 RejectedExecutionException 异常**、**忽略任务**、**使用提交任务的线程来执行此任务**和**将队列中等待最久的任务删除，然后提交此任务**这四种策略，默认为抛出异常。

#### 说说线程池中的线程创建时机？

> 1. 如果当前线程数少于 corePoolSize，那么提交任务的时候创建一个新的线程，并由这个线程执行这个任务；
> 2. 如果当前线程数已经达到 corePoolSize，那么将提交的任务添加到阻塞队列中，等待线程池中的线程去阻塞队列中取任务；
> 3. 如果阻塞队列已满，那么创建新的线程来执行任务，需要保证池中的线程数不会超过 maximumPoolSize，如果此时线程数超过了 maximumPoolSize，那么执行拒绝策略。

#### 什么时候会执行拒绝策略？

> 1. workers 的数量达到了 corePoolSize（任务此时需要进入任务队列），任务入队成功，与此同时线程池被关闭了，而且关闭线程池并没有将这个任务出队，那么执行拒绝策略。这里说的是非常边界的问题，入队和关闭线程池并发执行，读者仔细看看 execute 方法是怎么进到第一个 reject(command) 里面的。
> 2. workers 的数量大于等于 corePoolSize，将任务加入到任务队列，可是队列满了，任务入队失败，那么准备开启新的线程，可是线程数已经达到 maximumPoolSize，那么执行拒绝策略。

### Atomic原子类

#### 基本类型原子类

​	`AtomicInteger`类

#### 数组类型原子类

​	`AtomicIntegerArray`类

#### 引用类型原子类

​	基本原子类只更新一个变量，引用原子类可**更新多个变量**：

- `AtomicReference`类
- `AtomicStampedReference`类：带有版本号，解决CAS的ABA问题
- `AtomicMarkableReference`类：带有标记

#### 对象属性修改类型原子类



### Spring

#### IoC和AOP

​	IoC控制反转：传统程序通过程序员自身在类内`new`依赖对象，现在通过IoC容器注入依赖对象。依赖注入(DI)是实现控制反转的方式。
​	AOP：面向切面编程，即在不改变原有程序的基础上，横向扩展功能。

#### Spring中涉及的设计模式

#### 常见注解



## 数据库

### mysql

#### 事务的特性？

​	**原子性：** 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；
​	**一致性：** 执行事务前后，数据保持一致，例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的；
​	**隔离性：** 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；
​	**持久性：** 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。

#### 并发事务带来的问题？

​	**脏读**：一个事务访问并修改了数据，但没有提交到数据库。此时另一个事务也访问并使用了这个数据，那这个事务读取的数据是“脏数据”。
​	**幻读**：一个事务读取了几行数据，此时另一个并发事务写入了一些数据，第一个事务就会发现多了几条原本不存在的数据。
​	**丢失修改**：两个事务同时读取一个数据并修改，会导致先修改的事务的修改操作丢失。
​	**不可重复读**：一个事务在多次读取同一数据时，被另一个事务修改数据导致读取的数据内容前后不一致。

#### 事务的隔离级别？

​	**读取未提交**：允许读取尚未提交的数据，导致脏读、不可重复读、幻读；
​	**读取已提交**：允许读取并发事务已经提交的数据，阻止脏读，导致不可重复读、幻读；
​	**可重复读**：对同一字段的多次读取结果都是一致的，阻止脏读、不可重复读，导致幻读；
​	**可序列化(Serializable)**：所有事务依次逐个执行，最高隔离级别。

#### 为什么InnoDB使用B+树？

​	从结构比较来看，B树相比B+树的一个主要区别就在于B树的分支节点上存储着数据，而B+树的分支节点只是叶子节点的索引而已。

- 磁盘IO读写次数相比B树降低了
  在B+树中，其非叶子的内部节点都变成了key值，因此其内部节点相对B 树更小。如果把所有同一内部节点的key存放在同一盘块中，那么盘块所能容纳的key数量也越多。一次性读内存中的需要查找的key值也就越多。相对来说IO读写次数也就降低了。
- 每次查询的时间复杂度是固定的
  在B+树中，由于分支节点只是叶子节点的索引，所以对于任意关键字的查找都必须从根节点走到分支节点，所有关键字查询路径长度相同，每次查询的时间复杂度是固定的。但是在B树中，其分支节点上也保存有数据，对于每一个数据的查询所走的路径长度是不一样的，所以查询效率也不一样。
- 遍历效率更高
  由于B+树的数据都存储在叶子节点上，分支节点均为索引，方便扫库，只需扫一遍叶子即可。但是B树在分支节点上都保存着数据，要找到具体的顺序数据，需要执行一次中序遍历来查找。所以B+树更加适合范围查询的情况，在解决磁盘IO性能的同时解决了B树元素遍历效率低下的问题。
- **因为B树不管叶子节点还是非叶子节点，都会保存数据，这样导致在非叶子节点中能保存的指针数量变少（有些资料也称为扇出），指针少的情况下要保存大量数据，只能增加树的高度，导致IO操作变多，查询性能变低**

#### 锁机制--表锁与行锁

MyISAM和InnoDB存储引擎使用的锁：

- MyISAM采用表级锁(table-level locking)。
- InnoDB支持行级锁(row-level locking)和表级锁,默认为行级锁

表级锁和行级锁对比：

- **表级锁：** MySQL中锁定 **粒度最大** 的一种锁，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁。其锁定粒度最大，触发锁冲突的概率最高，并发度最低，MyISAM和 InnoDB引擎都支持表级锁。
- **行级锁：** MySQL中锁定 **粒度最小** 的一种锁，只针对当前操作的行进行加锁。 行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。

#### mysql数据库日志？

#### 分库分表

### Redis

#### 	缓存穿透和缓存雪崩

> 缓存穿透：大量请求的 key 根本不存在于缓存中，导致请求直接到了数据库上，根本没有经过缓存这一层。
> 解决方案：布隆过滤器

> 缓存雪崩：缓存在同一时间大面积的失效，后面的请求都直接落到了数据库上，造成数据库短时间内承受大量请求；或者有一些被大量访问数据（热点缓存）在某一时刻大面积失效，导致对应的请求直接落到了数据库上。
> 解决方案：合理设置过期时间时间；限流。

#### redis常见数据结构

​	String，List，Hash，Set，Sorted set

#### redis内存淘汰机制？

#### redis持久化机制？

#### redis缓存读写策略？

​	Cache Aside Pattern（旁路缓存模式）
​	Read/Write Through Pattern（读写穿透）
​	Write Behind Pattern（异步缓存写入）

## JVM

### 内存区域

#### 运行时数据区

##### 程序计数器

​	每条线程都需要有一个独立的程序计数器，各线程之间计数器互不影响，独立存储，我们称这类内存区域为**线程私有**的内存。
​	程序计数器不会出现OOM异常

##### java虚拟机栈

​	Java 虚拟机栈也是**线程私有**的，它的生命周期和线程相同，每次方法调用的数据都是通过栈传递的。
​	Java 虚拟机栈是由一个个**栈帧**组成，而每个栈帧中都拥有：**局部变量表、操作数栈、动态链接、方法出口信息**。
​	**局部变量表**主要存放了编译期可知的各种数据类型（boolean、byte、char、short、int、float、long、double），对象引用（reference 类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。

​	Java 虚拟机栈会出现两种错误：`StackOverFlowError` 和 `OutOfMemoryError`

​	java方法的调用：
​	Java 栈中保存的主要内容是栈帧，每一次函数调用都会有一个对应的栈帧被压入 Java 栈，每一个函数调用结束后，都会有一个栈帧被弹出。Java 方法有两种返回方式：return 语句；抛出异常。不管哪种返回方式都会导致栈帧被弹出。

##### 本地方法栈

​	本地方法栈为虚拟机使用到的 Native 方法服务。本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。

##### java堆

​	Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，**几乎所有**的对象实例以及数组都在这里分配内存。（有些在栈上分配内存）
​	Java 堆还可以细分为：新生代和老年代；或：Eden 空间、From Survivor、To Survivor 空间等（8:1:1）。JDK8后永久代被移除到元空间中。

​	java堆容易出现`OutOfMemoryError`异常。

##### 方法区

​	方法区是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。

##### 运行时常量池

​	运行时常量池是**方法区**的一部分（OOM异常）。Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有常量池表（用于存放编译期生成的各种字面量和符号引用）
​	**字符串常量池**被单独拿到**堆**,运行时常量池剩下的东西还在方法区。

#### 对象的创建步骤

​	1、类加载检查：虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。
​	2、分配内存：在**类加载检查**通过后，接下来虚拟机将为新生对象**分配内存**。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。**分配方式**有 **“指针碰撞”** 和 **“空闲列表”** 两种，**选择哪种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定**。
​	3、初始化零值：虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。
​	4、设置对象头：对对象进行设置，包括这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 **这些信息存放在对象头中。**
​	5、执行<init>方法。

##### String s1 = new String("abc")创建了几个对象？

​	创建 1 或 2 个字符串。如果池中已存在字符串常量“abc”，则只会在堆空间创建一个字符串常量“abc”。如果池中没有字符串常量“abc”，那么它将首先在池中创建，然后在堆空间中创建。

##### 如何判断对象已死？

​	**可达性分析**：这是一种类似于二叉树的实现，将一系列的GC ROOTS作为起始的存活对象集，从这个节点往下搜索，搜索所走过的路径成为引用链，把能被该集合引用到的对象加入到集合中。搜索当一个对象到GC Roots没有使用任何引用链时，则说明该对象是不可用的。（解决了**引用计数器法**的**循环引用**问题）

### 类加载过程

​	加载->验证->准备->解析->初始化
​	加载：通过全类名获取定义此类的二进制字节流；将字节流所代表的静态存储结构转换为方法区的运行时数据结构；在内存中生成一个代表该类的 Class 对象,作为方法区这些数据的访问入口。
​	验证：
​	准备：准备阶段是正式为**类变量（static）**分配内存并设置类变量初始值（0、0L、null、false等，`final`修饰的直接赋值）的阶段，这些内存都将在**方法区**中分配。
​	解析：解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，也就是得到类或者字段、方法在内存中的指针或者偏移量。解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用限定符7类符号引用进行。**符号引用**就是一组符号来描述目标，可以是任何字面量。**直接引用**就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。
​	初始化：执行初始化方法 `<clinit> ()`方法的过程。

### 类加载器

#### JAVA类加载机制双亲委派？

​	如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就**成功返回**，倘若父类加载器无法完成此加载任务，**子加载器才会尝试自己去加载**。

