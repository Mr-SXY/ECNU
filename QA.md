#### **范型 类型擦除**

#### **重写equals()必须重写hashcode()？**

​	对于基本类型	==	比较的是数值；对于引用数据类型	==	比较的是地址

​	equals()	源码就是	==	；不能用于比较基本数据类型。

​	*若两个对象相等，则hashcode一定相等；但两个对象的hashcode相等，他们不一定equals()。*

> Sting中的equals方法是**重写**过的，Object的equals方法比较的是`对象的内存地址`，而String比较的是`对象的值`；创建String类对象时，虚拟机会在常量池中查找有没有 已经存在的与要创建的值相同的对象，如果有就把他赋给当前引用。

构造方法的作用：用于类对象的初始化

多态

从键盘输入两种方法：BufferedReader	/	Scanner

字节/字符流	BIO/NIO/AIO

POJO类属性使用包装类数据类型；RPC方法的返回值使用包装数据类型；局部变量使用基本数据类型

浮点数之间的等值判断采用BigDecimal	（精度丢失）

Arrays.asList()方法：1、返回的是Arrays的内部类而不是ArrayList；2、是一个泛型方法，传入的数组需为对象数组，若传入int[]（基本类型数组），则整个数组作为List的唯一元素。

equals()的空指针异常

不在foreach里进行list的add(),remove()操作，可用iterator或者list.removeIf()方法



#### **并发事务带来的问题？**

- ​	**脏读**：一个事务访问并修改了数据，但没有提交到数据库。此时另一个事务也访问并使用了这个数据，那这个事务读取的数据是“脏数据”。

- ​	**幻读**：一个事务读取了几行数据，此时另一个并发事务写入了一些数据，第一个事务就会发现多了几条原本不存在的数据。

- ​	**丢失修改**：两个事务同时读取一个数据并修改，会导致先修改的事务的修改操作丢失。

- ​	**不可重复读**：一个事务在多次读取同一数据时，被另一个事务修改数据导致读取的数据内容前后不一致。


#### **事务的隔离级别？**

- ​	**读取未提交**：允许读取尚未提交的数据，导致脏读、不可重复读、幻读；

- ​	**读取已提交**：允许读取并发事务已经提交的数据，阻止脏读，导致不可重复读、幻读；

- ​	**可重复读**：对同一字段的多次读取结果都是一致的，阻止脏读、不可重复读，导致幻读；

- ​	**可序列化(Serializable)**：所有事务依次逐个执行，最高隔离级别。


#### **为什么InnoDB使用B+树？**



#### **final关键字的特点：**

- ​	final修饰的类不能被继承，final类中的所有成员方法都会被隐式的指定为final方法；
- ​	final修饰的方法不能被重写；
- ​	final修饰的变量是常量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能让其指向另一个对象。



#### **计算机网络7层模型**

​	物理层，数据链路层，网络层，传输层，会话层，表示层，应用层

#### **应用层协议有哪些？**



#### **浏览器输入URL之后的过程？**



#### **HTTP状态码**

​	200 - 请求成功

​	301 - 资源（网页）被永久转移到其他URL

​	302 - 资源（网页）被临时移动到其他URL

​	404 - 请求的资源不存在

​	500 - 内部服务器错误；

#### **HTTP状态码分类**：

​	1**	：信息，服务器收到请求，需要请求者继续执行操作

​	2**	： 成功，操作被成功接收并处理

​	3**	：重定向，需要进一步的操作以完成请求

​	4**	：客户端错误，请求包含语法错误或无法完成请求

​	5**	：服务器错误，服务器在处理请求的过程中发生了错误

#### **四次挥手过程？**

#### **三次握手有哪些攻击方式？**

#### **证书在SSL过程中的作用？**

#### **HTTPS通信过程以及SSL为什么采用混合加密方式？**

#### **线程池的七大参数？**



#### **操作系统的PageFault？**

#### **Mysql的B+树索引和红黑树、普通二叉树的区别？**

#### **CAS、ABA、如何保证原子性？**

#### **描述volatile**

#### **原子类的实现方式**

#### **锁的AQS的实现方式**

#### **列举知道的锁**

#### **JAVA类加载机制双亲委派？**

#### **JAVA	GC算法？**

#### **HashMap扩容机制，线程安全？ConCurrentHashMap？**

#### **引用**

​	由强到弱分为`强引用`；`软引用`：SoftReference类实现；`弱引用`：WeakReference类实现；`虚引用`：PhantomReference类实现，共4种。

#### **死锁的四个条件**

- ​	互斥条件：该资源任意一个时刻只有一个线程占用；

- ​	请求与保持条件：一个进程由于请求资源而阻塞，对已经获得的资源保持不放；

- ​	不剥夺条件：线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源；

- ​	循环等待条件：若干进程之间形成一种首尾相连的的循环等待资源的关系。


#### **乐观锁与悲观锁**

​	乐观锁多用于**多读**的场景，悲观锁多用于**多写**的场景。

​	乐观锁主要的两种实现方式：版本号机制、CAS

#### **乐观锁的缺点**

- ​	ABA问题：JDK 1.5 以后的 `AtomicStampedReference 类`就提供了此种能力，其中的 `compareAndSet 方法`就是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。
- ​	循环时间长，开销大：自旋CAS长时间不成功会带来执行开销。
- ​	只能保证一个共享变量的原子操作：`AtomicReference类`来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行 CAS 操作.所以我们可以使用锁或者利用`AtomicReference类`把多个共享变量合并成一个共享变量来操作。

#### **this, super不能用在static方法中？**

​	被 static 修饰的成员属于类，不属于单个这个类的某个对象，被类中所有对象共享。而 this 代表对本类对象的引用，指向本类对象；而 super 代表对父类对象的引用，指向父类对象；所以， **this和super是属于对象范畴的东西，而静态方法是属于类范畴的东西**。

### **static{}静态代码块与{}非静态代码块**

​	执行顺序：静态代码块 > 非静态代码块 > 构造方法 > 静态方法中的内容 > 静态方法中代码块。

### java 线程池有哪些关键属性？

> corePoolSize，maximumPoolSize，workQueue，keepAliveTime，rejectedExecutionHandler
>
> corePoolSize 到 maximumPoolSize 之间的线程会被回收，当然 corePoolSize 的线程也可以通过设置而得到回收（allowCoreThreadTimeOut(true)）。
>
> workQueue 用于存放任务，添加任务的时候，如果当前线程数超过了 corePoolSize，那么往该队列中插入任务，线程池中的线程会负责到队列中拉取任务。
>
> keepAliveTime 用于设置空闲时间，如果线程数超出了 corePoolSize，并且有些线程的空闲时间超过了这个值，会执行关闭这些线程的操作
>
> rejectedExecutionHandler 用于处理当线程池不能执行此任务时的情况，默认有**抛出 RejectedExecutionException 异常**、**忽略任务**、**使用提交任务的线程来执行此任务**和**将队列中等待最久的任务删除，然后提交此任务**这四种策略，默认为抛出异常。

### 说说线程池中的线程创建时机？

> 1. 如果当前线程数少于 corePoolSize，那么提交任务的时候创建一个新的线程，并由这个线程执行这个任务；
> 2. 如果当前线程数已经达到 corePoolSize，那么将提交的任务添加到队列中，等待线程池中的线程去队列中取任务；
> 3. 如果队列已满，那么创建新的线程来执行任务，需要保证池中的线程数不会超过 maximumPoolSize，如果此时线程数超过了 maximumPoolSize，那么执行拒绝策略。

### 什么时候会执行拒绝策略？

> 1. workers 的数量达到了 corePoolSize（任务此时需要进入任务队列），任务入队成功，与此同时线程池被关闭了，而且关闭线程池并没有将这个任务出队，那么执行拒绝策略。这里说的是非常边界的问题，入队和关闭线程池并发执行，读者仔细看看 execute 方法是怎么进到第一个 reject(command) 里面的。
> 2. workers 的数量大于等于 corePoolSize，将任务加入到任务队列，可是队列满了，任务入队失败，那么准备开启新的线程，可是线程数已经达到 maximumPoolSize，那么执行拒绝策略。