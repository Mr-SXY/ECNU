#### 什么是二叉排序树

​	二叉排序树即二叉查找树，满足若左子树不空，则左子树上所有结点的值均小于它的根结点的值；若右子树不空，则右子树上所有结点的值均大于或等于它的根结点的值；左、右子树也分别为二叉排序树；

#### **范型 类型擦除**

​	自动装箱用的是ValueOf方法`Integer i = 3`；当执行算术运算时，会自动拆箱。

#### **重写equals()必须重写hashcode()？**

​	对于基本类型	==	比较的是数值；对于引用数据类型	==	比较的是地址
​	equals()	源码就是	==	；不能用于比较基本数据类型。
​	*若两个对象相等，则hashcode一定相等；但两个对象的hashcode相等，他们不一定equals()。*

> Sting中的equals方法是**重写**过的，Object的equals方法比较的是`对象的内存地址`，而String比较的是`对象的值`；创建String类对象时，虚拟机会在常量池中查找有没有 已经存在的与要创建的值相同的对象，如果有就把他赋给当前引用。

构造方法的作用：用于类对象的初始化

多态

从键盘输入两种方法：BufferedReader	/	Scanner

字节/字符流	BIO/NIO/AIO

POJO类属性使用包装类数据类型；RPC方法的返回值使用包装数据类型；局部变量使用基本数据类型

浮点数之间的等值判断采用BigDecimal	（精度丢失）

Arrays.asList()方法：1、返回的是Arrays的内部类而不是ArrayList；2、是一个泛型方法，传入的数组需为对象数组，若传入int[]（基本类型数组），则整个数组作为List的唯一元素。

equals()的空指针异常

不在foreach里进行list的add(),remove()操作，可用iterator或者list.removeIf()方法

网关



#### **final关键字的特点：**

- ​	final修饰的类不能被继承，final类中的所有成员方法都会被隐式的指定为final方法；
- ​	final修饰的方法不能被重写；
- ​	final修饰的变量是常量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能让其指向另一个对象。

#### **计算机网络7层模型**

​	物理层，数据链路层，网络层，传输层，会话层，表示层，应用层

#### **应用层协议有哪些？**



#### **浏览器输入URL之后的过程？**



#### **HTTP状态码**

​	200 - 请求成功
​	301 - 资源（网页）被永久转移到其他URL
​	302 - 资源（网页）被临时移动到其他URL
​	404 - 请求的资源不存在
​	500 - 内部服务器错误；

#### **HTTP状态码分类**：

​	1**	：信息，服务器收到请求，需要请求者继续执行操作
​	2**	： 成功，操作被成功接收并处理
​	3**	：重定向，需要进一步的操作以完成请求
​	4**	：客户端错误，请求包含语法错误或无法完成请求
​	5**	：服务器错误，服务器在处理请求的过程中发生了错误

#### **四次挥手过程？**

#### **三次握手有哪些攻击方式？**

#### **证书在SSL过程中的作用？**

#### **HTTPS通信过程以及SSL为什么采用混合加密方式？**

#### 操作系统的PageFault？

#### 进程间通信方式？

1. 管道pipe：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。
2. 高级管道(popen)：将另一个程序当做一个新的进程在当前程序进程中启动，则它算是当前程序的子进程，这种方式我们成为高级管道方式。
3. 命名管道：有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。
4. 消息队列MessageQueue：消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。
5. 共享存储SharedMemory：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量，配合使用，来实现进程间的同步和通信。
6. 信号量Semaphore：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。
7. 套接字Socket：套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同及其间的进程通信。
8. 信号 ( signal ) ： 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。

#### java8新特性

#### this, super不能用在static方法中？

​	被 static 修饰的成员属于类，不属于单个这个类的某个对象，被类中所有对象共享。而 this 代表对本类对象的引用，指向本类对象；而 super 代表对父类对象的引用，指向父类对象；所以， **this和super是属于对象范畴的东西，而静态方法是属于类范畴的东西**。

#### static{}静态代码块与{}非静态代码块

​	执行顺序：静态代码块 > 非静态代码块 > 构造方法 > 静态方法中的内容 > 静态方法中代码块。

#### 引用

​	由强到弱分为`强引用`；`软引用`：SoftReference类实现；`弱引用`：WeakReference类实现；`虚引用`：PhantomReference类实现，共4种。

#### 接口和抽象类区别

​	相同：都不能被实例化 
​	不同：
​		接口只有定义，不能有**抽象**方法的实现，而抽象类可以有定义与实现，方法可在抽象类中实现；
​		一个类可以实现多个接口，但一个类只能继承一个抽象类；


### 锁

#### 列举知道的锁

​	行锁和表锁，乐观锁和悲观锁，独占锁和共享锁，公平锁和非公平锁，分段锁。

#### 死锁的四个条件

- ​	互斥条件：该资源任意一个时刻只有一个线程占用；
- ​	请求与保持条件：一个进程由于请求资源而阻塞，对已经获得的资源保持不放；
- ​	不剥夺条件：线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源；
- ​	循环等待条件：若干进程之间形成一种首尾相连的的循环等待资源的关系。

#### 乐观锁与悲观锁

​	乐观锁多用于**多读**的场景，悲观锁多用于**多写**的场景。

​	乐观锁主要的两种实现方式：版本号机制、CAS

##### 	乐观锁的缺点

- ​	ABA问题：JDK 1.5 以后的 `AtomicStampedReference 类`就提供了此种能力，其中的 `compareAndSet 方法`就是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。
- ​	循环时间长，开销大：自旋CAS长时间不成功会带来执行开销。
- ​	只能保证一个共享变量的原子操作：`AtomicReference类`来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行 CAS 操作.所以我们可以使用锁或者利用`AtomicReference类`把多个共享变量合并成一个共享变量来操作。

#### CAS解决ABA问题，如何保证原子性？

​	计数器法；版本号法	

#### 分段锁

​	分段锁是一种锁的设计，细化了锁的粒度，对于`ConcurrentHashMap`，其并发实现就是通过分段锁的形式。其分段锁称为`Segment`，即`HashMap`中的`Entry`数组，数组中每个元素存的都是链表。`Segment`继承了`ReentrantLock`。
​	当`putVal`的时候，不是对整个`HashMap`加锁，而是对`hashcode`指向的分段加锁，实现了并行插入。

#### 描述volatile

#### 原子类的实现方式

#### 锁的AQS的实现方式



### 容器

#### HashMap

​	HashMap线程不安全，主要通过数组加链表实现，当链表长度**达到8**时，先考虑给table扩容，当**达到64**时，链表才转化为红黑树；当红黑树节点数**小于等于6**时可能退化为链表。
> 红黑树是一个特殊的平衡二叉树，查找复杂度O(logn)
#### HashMap扩容机制

#### HashTable和HashMap区别

​	hashtable的方法是同步的，而hashmap不是；
​	hashtable的key 和value都不可以为null,而hashmap可以

#### ConCurrentHashMap

#### ArrayList扩容机制

### 线程池

#### 线程池的七大参数？

​	线程池的构造函数有7个参数，分别是corePoolSize、maximumPoolSize、keepAliveTime、unit、workQueue、threadFactory、handler.
- corePoolSize：核心线程数
- maximumPoolSize：最大线程数，线程池允许创建的最大线程数。
- workQueue：
  任务队列，BlockingQueue 接口的某个实现（常使用 ArrayBlockingQueue 和 LinkedBlockingQueue）。
- keepAliveTime：
  空闲线程的保活时间，如果某线程的空闲时间超过这个值都没有任务给它做，那么可以被关闭了。注意这个值并不会对所有线程起作用，如果线程池中的线程数少于等于核心线程数 corePoolSize，那么这些线程不会因为空闲太长时间而被关闭，当然，也可以通过调用 `allowCoreThreadTimeOut(true)`使核心线程数内的线程也可以被回收。
- unit：空闲线程存活时间单位
- threadFactory：用于生成线程
- handler：拒绝策略	

#### java 线程池有哪些关键属性？

> corePoolSize，maximumPoolSize，workQueue，keepAliveTime，rejectedExecutionHandler
> corePoolSize 到 maximumPoolSize 之间的线程会被回收，当然 corePoolSize 的线程也可以通过设置而得到回收（allowCoreThreadTimeOut(true)）。
> workQueue 用于存放任务，添加任务的时候，如果当前线程数超过了 corePoolSize，那么往该队列中插入任务，线程池中的线程会负责到队列中拉取任务。
> keepAliveTime 用于设置空闲时间，如果线程数超出了 corePoolSize，并且有些线程的空闲时间超过了这个值，会执行关闭这些线程的操作
> rejectedExecutionHandler 用于处理当线程池不能执行此任务时的情况，默认有**抛出 RejectedExecutionException 异常**、**忽略任务**、**使用提交任务的线程来执行此任务**和**将队列中等待最久的任务删除，然后提交此任务**这四种策略，默认为抛出异常。

#### 说说线程池中的线程创建时机？

> 1. 如果当前线程数少于 corePoolSize，那么提交任务的时候创建一个新的线程，并由这个线程执行这个任务；
> 2. 如果当前线程数已经达到 corePoolSize，那么将提交的任务添加到阻塞队列中，等待线程池中的线程去阻塞队列中取任务；
> 3. 如果阻塞队列已满，那么创建新的线程来执行任务，需要保证池中的线程数不会超过 maximumPoolSize，如果此时线程数超过了 maximumPoolSize，那么执行拒绝策略。

#### 什么时候会执行拒绝策略？

> 1. workers 的数量达到了 corePoolSize（任务此时需要进入任务队列），任务入队成功，与此同时线程池被关闭了，而且关闭线程池并没有将这个任务出队，那么执行拒绝策略。这里说的是非常边界的问题，入队和关闭线程池并发执行，读者仔细看看 execute 方法是怎么进到第一个 reject(command) 里面的。
> 2. workers 的数量大于等于 corePoolSize，将任务加入到任务队列，可是队列满了，任务入队失败，那么准备开启新的线程，可是线程数已经达到 maximumPoolSize，那么执行拒绝策略。

### Atomic原子类

#### 基本类型原子类

​	`AtomicInteger`类

#### 数组类型原子类

​	`AtomicIntegerArray`类

#### 引用类型原子类

​	基本原子类只更新一个变量，引用原子类可**更新多个变量**：

- `AtomicReference`类
- `AtomicStampedReference`类：带有版本号，解决CAS的ABA问题
- `AtomicMarkableReference`类：带有标记

#### 对象属性修改类型原子类



### Spring

#### IoC和AOP
​	IoC控制反转：传统程序通过程序员自身在类内`new`依赖对象，现在通过IoC容器注入依赖对象。依赖注入(DI)是实现控制反转的方式。
​	AOP：面向切面编程，即在不改变原有程序的基础上，横向扩展功能。

#### Spring中涉及的设计模式
​	代理模式
​	模板方法模式
​	工厂模式

#### 常见注解
​	@Component
​	@Autowired
​	@Value
​	@Bean

#### 事务传播机制

​	Spring事务机制主要包括声明式事务和编程式事务；
​	spring在`TransactionDefinition`接口中定义了七个事务传播行为：
​		**propagation_requierd**：如果当前没有事务，就新建一个事务，如果已存在一个事务中，加入到这个事务中，这是最常见的选择。
​		**propagation_supports**：支持当前事务，如果没有当前事务，就以非事务方法执行。
​		**propagation_mandatory**：使用当前事务，如果没有当前事务，就抛出异常。
​		**propagation_required_new**：新建事务，如果当前存在事务，把当前事务挂起。
​		**propagation_not_supported**：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。
​		**propagation_never**：以非事务方式执行操作，如果当前事务存在则抛出异常。
​		**propagation_nested**：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与propagation_required类似的操作

## 数据库

### mysql

> mysql是一个关系型数据库，有固定的格式，行和列。

#### 事务的特性？

​	**原子性：** 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；
​	**一致性：** 执行事务前后，数据保持一致，例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的；
​	**隔离性：** 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；
​	**持久性：** 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。

#### 并发事务带来的问题？

​	**脏读**：一个事务访问并修改了数据，但没有提交到数据库。此时另一个事务也访问并使用了这个数据，那这个事务读取的数据是“脏数据”。
​	**幻读**：一个事务读取了几行数据，此时另一个并发事务写入了一些数据，第一个事务就会发现多了几条原本不存在的数据。
​	**丢失修改**：两个事务同时读取一个数据并修改，会导致先修改的事务的修改操作丢失。
​	**不可重复读**：一个事务在多次读取同一数据时，被另一个事务修改数据导致读取的数据内容前后不一致。

#### 事务的隔离级别？

​	**读取未提交**：允许读取尚未提交的数据，导致脏读、不可重复读、幻读；
​	**读取已提交**：允许读取并发事务已经提交的数据，阻止脏读，导致不可重复读、幻读；
​	**可重复读**：对同一字段的多次读取结果都是一致的，阻止脏读、不可重复读，导致幻读；
​	**可序列化(Serializable)**：所有事务依次逐个执行，最高隔离级别。

#### 为什么InnoDB使用B+树？

​	从结构比较来看，B树相比B+树的一个主要区别就在于B树的分支节点上存储着数据，而B+树的分支节点只是叶子节点的索引而已。

- 磁盘IO读写次数相比B树降低了
  在B+树中，其非叶子的内部节点都变成了key值，因此其内部节点相对B 树更小。如果把所有同一内部节点的key存放在同一盘块中，那么盘块所能容纳的key数量也越多。一次性读内存中的需要查找的key值也就越多。相对来说IO读写次数也就降低了。
- 每次查询的时间复杂度是固定的
  在B+树中，由于分支节点只是叶子节点的索引，所以对于任意关键字的查找都必须从根节点走到分支节点，所有关键字查询路径长度相同，每次查询的时间复杂度是固定的。但是在B树中，其分支节点上也保存有数据，对于每一个数据的查询所走的路径长度是不一样的，所以查询效率也不一样。
- 遍历效率更高
  由于B+树的数据都存储在叶子节点上，分支节点均为索引，方便扫库，只需扫一遍叶子即可。但是B树在分支节点上都保存着数据，要找到具体的顺序数据，需要执行一次中序遍历来查找。所以B+树更加适合范围查询的情况，在解决磁盘IO性能的同时解决了B树元素遍历效率低下的问题。
- **因为B树不管叶子节点还是非叶子节点，都会保存数据，这样导致在非叶子节点中能保存的指针数量变少（有些资料也称为扇出），指针少的情况下要保存大量数据，只能增加树的高度，导致IO操作变多，查询性能变低**

#### 锁机制--表锁与行锁

MyISAM和InnoDB存储引擎使用的锁：

- MyISAM采用表级锁(table-level locking)。
- InnoDB支持行级锁(row-level locking)和表级锁,默认为行级锁

表级锁和行级锁对比：

- **表级锁：** MySQL中锁定 **粒度最大** 的一种锁，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁。其锁定粒度最大，触发锁冲突的概率最高，并发度最低，MyISAM和 InnoDB引擎都支持表级锁。

- **行级锁：** MySQL中锁定 **粒度最小** 的一种锁，只针对当前操作的行进行加锁。 行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。

 **mysql上共享锁**的命令：在最后加上lock in share mode

#### mysql数据库日志？

#### 优化数据库的方法？

​	Explain：待补充。。。。
​	覆盖索引：在我们建立的索引上就已经有我们需要的字段，不需要回表，优化性能。
​	联合索引：
​	前缀索引：定义字符串的一部分作索引。

#### 什么情况需要分库分表

#### 垂直拆分和水平拆分

​	垂直拆分：读写分离，一个mysql数据库专门用来写，其他数据库读取其中的数据。解决读的压力

​	水平拆分（集群）：

### NoSQL

##### NoSQL四大分类

​	KV键值对；文档型数据库（MongoDB：非关系型数据库中最像关系型数据库的）；列存储数据库；图形关系数据库。

#### Redis

> redis是非关系型数据库，可存储用户个人信息、社交网络、地理位置等

##### redis安装&&命令

​	官网下载tar.gz后解压，放在opt/下，cd目录后make，make install，安装在usr/local/bin下，将下载的redis.config配置文件拷贝至usr/local/bin/Kconfig下，vim修改daemonize为yes，然后`redis-server Kconfig/redis.conf`启动服务,使用redis-cli连接`redis-cli -p 6379`（redis默认端口号6379）。`shutdown`redis-server关闭，`exit`redis-cli退出。

​	redis有**16**个数据库，默认使用第0个，可用select进行切换：`select 3`
​	查看当前数据库大小：`dbsize`
​	查看所有的key：`keys *`
​	清除当前数据库：`flushdb`
​	清除全部数据库：`flushall`
​	判断key是否存在：`EXISTS xxxx`
​	移除当前key：`move xxxx 1`
​	设置key的过期时间：`EXPIRE xxxx 10`
​	查看当前key剩余时间：`ttl xxxx`
​	查看key类型：`type xxxx`
​	截取字符串：`GETRANGE xxxx 0 3`
​	设置过期时间：`setex`（单个）`msetex`
​	不存在则设置：`setnx`（单个）`msetnx`（原子操作）

##### 缓存穿透和缓存雪崩

> 缓存穿透：大量请求的 key 根本不存在于缓存中，导致请求直接到了数据库上，根本没有经过缓存这一层。
> 解决方案：<a herf="https://snailclimb.gitee.io/javaguide/#/docs/dataStructures-algorithms/data-structure/bloom-filter">布隆过滤器</a>

> 缓存雪崩：缓存在同一时间大面积的失效，后面的请求都直接落到了数据库上，造成数据库短时间内承受大量请求；或者有一些被大量访问数据（热点缓存）在某一时刻大面积失效，导致对应的请求直接落到了数据库上。
> 解决方案：合理设置过期时间时间；限流。

##### redis常见数据结构

​	Redis-Key，String，List，Hash（key-map），Set，Sorted set

##### redis单线程为什么这么快？

​	redis将所有数据放在内存中，使用单线程操作效率最高，多线程（CPU上下文切换耗时）。

##### redis内存淘汰机制？

##### redis持久化机制？

​	RDB

​	AOF

##### redis哨兵模式

##### redis缓存读写策略？

​	Cache Aside Pattern（旁路缓存模式）
​	Read/Write Through Pattern（读写穿透）
​	Write Behind Pattern（异步缓存写入）

## JVM

### 内存区域

#### 运行时数据区

##### 程序计数器

​	每条线程都需要有一个独立的程序计数器，各线程之间计数器互不影响，独立存储，我们称这类内存区域为**线程私有**的内存。
​	程序计数器不会出现OOM异常

##### java虚拟机栈

​	Java 虚拟机栈也是**线程私有**的，它的生命周期和线程相同，每次方法调用的数据都是通过栈传递的。
​	Java 虚拟机栈是由一个个**栈帧**组成，而每个栈帧中都拥有：**局部变量表、操作数栈、动态链接、方法出口信息**。
​	**局部变量表**主要存放了编译期可知的各种数据类型（boolean、byte、char、short、int、float、long、double），对象引用（reference 类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。

​	Java 虚拟机栈会出现两种错误：`StackOverFlowError` 和 `OutOfMemoryError`

​	java方法的调用：
​	Java 栈中保存的主要内容是栈帧，每一次函数调用都会有一个对应的栈帧被压入 Java 栈，每一个函数调用结束后，都会有一个栈帧被弹出。Java 方法有两种返回方式：return 语句；抛出异常。不管哪种返回方式都会导致栈帧被弹出。

##### 本地方法栈

​	本地方法栈为虚拟机使用到的 Native 方法服务。本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。

##### java堆

​	Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，**几乎所有**的对象实例以及数组都在这里分配内存。（有些在栈上分配内存）
​	Java 堆还可以细分为：新生代和老年代；或：Eden 空间、From Survivor、To Survivor 空间等（8:1:1）。JDK8后永久代被移除到元空间中。

​	java堆容易出现`OutOfMemoryError`异常。

##### 方法区

​	方法区是各个线程共享的内存区域，它用于存储**已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码**等数据。

##### 运行时常量池

​	运行时常量池是**方法区**的一部分（OOM异常）。Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有常量池表（用于存放编译期生成的各种字面量和符号引用）

​	**字符串常量池**被单独拿到**堆**,运行时常量池剩下的东西还在方法区。

#### 对象的创建步骤

​	1、类加载检查：虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。
​	2、分配内存：在**类加载检查**通过后，接下来虚拟机将为新生对象**分配内存**。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。**分配方式**有 **“指针碰撞”** 和 **“空闲列表”** 两种，**选择哪种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定**。
​	3、初始化零值：虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。
​	4、设置对象头：对对象进行设置，包括这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 **这些信息存放在对象头中。**
​	5、执行<init>方法。

##### String s1 = new String("abc")创建了几个对象？

​	创建 1 或 2 个字符串。如果池中已存在字符串常量“abc”，则只会在堆空间创建一个字符串常量“abc”。如果池中没有字符串常量“abc”，那么它将首先在池中创建，然后在堆空间中创建。

### 类加载过程

​	加载->验证->准备->解析->初始化
​	加载：通过全类名获取定义此类的二进制字节流；将字节流所代表的静态存储结构转换为方法区的运行时数据结构；在内存中生成一个代表该类的 Class 对象,作为方法区这些数据的访问入口。
​	验证：
​	准备：准备阶段是正式为**类变量（static）**分配内存并设置类变量初始值（0、0L、null、false等，`final`修饰的直接赋值）的阶段，这些内存都将在**方法区**中分配。
​	解析：解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，也就是得到类或者字段、方法在内存中的指针或者偏移量。解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用限定符7类符号引用进行。**符号引用**就是一组符号来描述目标，可以是任何字面量。**直接引用**就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。
​	初始化：执行初始化方法 `<clinit> ()`方法的过程。

### 类加载器

#### JAVA类加载机制双亲委派？

​	如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就**成功返回**，倘若父类加载器无法完成此加载任务，**子加载器才会尝试自己去加载**。

### JVM垃圾回收

#### 如何判断对象已死？

​	**可达性分析**：这是一种类似于二叉树的实现，将一系列的GC ROOTS作为起始的存活对象集，从这个节点往下搜索，搜索所走过的路径成为引用链，把能被该集合引用到的对象加入到集合中。搜索当一个对象到GC Roots没有使用任何引用链时，则说明该对象是不可用的。（解决了**引用计数器法**的**循环引用**问题）

​	**判断废弃常量**：常量池中没有任何String对象引用常量，则为废弃常量。

#### 判断无用类？

必要条件：
​	该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。
​	加载该类的 `ClassLoader` 已经被回收。
​	该类对应的 `java.lang.Class` 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

#### GC区域

部分收集 (Partial GC)：
​	**新生代收集**（Minor GC / Young GC）：只对新生代进行垃圾收集；
​	老年代收集（Major GC / Old GC）：只对老年代进行垃圾收集。需要注意的是 Major GC 在有的语境中也用于指代整堆收集；
​	混合收集（Mixed GC）：对整个新生代和部分老年代进行垃圾收集。
**整堆收集** (Full GC)：收集整个 Java 堆和方法区。

#### 垃圾收集算法

​	标记-清除：首先标记出所有不需要回收的对象，在标记完成后统一回收掉所有没有被标记的对象；
​	标记-复制：为了解决效率问题，“标记-复制”收集算法出现了。它可以将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收；
​	标记-整理：根据老年代的特点提出的一种标记算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存；
​	**分代收集**：根据java堆各个年代的特点选择合适的收集策略。新生代（标记复制），老年代（标记整理/清除）。

#### 垃圾收集器

​	Serial收集器
​	Parallel Scavenge 收集器
​	CMS收集器：
​	G1收集器的特点：
​		**并行与并发**：G1 能充分利用 CPU、多核环境下的硬件优势，使用多个 CPU（CPU 或者 CPU 核心）来缩短 Stop-The-World 停顿时间。部分其他收集器原本需要停顿 Java 线程执行的 GC 动作，G1 收集器仍然可以通过并发的方式让 java 程序继续执行。
​		**分代收集**：虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但是还是保留了分代的概念。
​		**空间整合**：与 CMS 的“标记-清理”算法不同，G1 从整体来看是基于“标记-整理”算法实现的收集器；从局部上来看是基于“标记-复制”算法实现的。
​		**可预测的停顿**：这是 G1 相对于 CMS 的另一个大优势，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内。

